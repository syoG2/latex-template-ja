%! TEX root = ../main.tex
\documentclass[main]{subfiles}

\begin{document}
\chapter{課題4}
\section{目的・概要}
課題4では,演算子や代入のコード生成を行えるようにcompiler.pyに追加実装を行い,実際にコンパイルを行うことができるか確認した.

\section{使用機器・ソフトウェア}
\begin{itemize}
    \item Cent OS version 6.4(64ビット版)
    \item Python 3.9.16
    \item PLYパッケージ
\end{itemize}

\section{作業内容・プログラムの内容}
\subsection{作業内容}
この課題では,以下のファイルを用いてここに実装を追加した.
\lstinputlisting[caption=sample-program/kadai4/compiler.py,label=code:sample-program/kadai4/compiler.py,language=Python]{../src/sample-program/kadai4/compiler.py}
\lstinputlisting[caption=sample-program/kadai4/fundef.py,label=code:sample-program/kadai4/fundef.py,language=Python]{../src/sample-program/kadai4/fundef.py}
\lstinputlisting[caption=sample-program/kadai4/llvmcode.py,label=code:sample-program/kadai4/llvmcode.py,language=Python]{../src/sample-program/kadai4/llvmcode.py}
\lstinputlisting[caption=sample-program/kadai4/operand.py,label=code:sample-program/kadai4/operand.py,language=Python]{../src/sample-program/kadai4/operand.py}
% \lstinputlisting[caption=sample-program/kadai4/symtab.py,label=code:sample-program/kadai4/symtab.py,language=Python]{../src/sample-program/kadai4/symtab.py}
compiler.pyには生成した関数定義(Fundef)のリスト,write関数が使用されているか,read関数が使用されているかのフラグ,関数定義オブジェクトのcodesに命令を追加するaddCode関数,新たなレジスタ番号を持つOperandオブジェクトを返すgetRegister関数が新たに実装されていた.
また,一部の構文規則に対してコード生成のための処理が記述されていた.
fundef.pyには関数定義クラスが記述されており,関数は関数名,返り値の型,LLVMコード列,レジスタ番号カウンタがプロパティとして定義されており,新しいレジスタ番号を取得するメソッドも定義されていた.
llvmcode.pyには一部のLLVMコードを生成する関数が定義されていた.
operand.pyには大域変数,レジスタ,定数を表現するOperandクラスが定義されていた.
compiler.pyに以下の実装を追加した.
\begin{oframed}
\textbf{実装内容}
\begin{itemize}
    \item \verb|"proc_name -> IDENT": 宣言された手続きを記号表に追加し,その後のスコープを局所変数に変更|
    \item \verb|"assignment_statement": IDENT ASSIGN expression":代入先の変数を記号表から探し,store命令を生成|
    \item \verb|"expression -> MINUS term": sub命令を追加して0からtermの値を引いた値を計算する|
    \item \verb|"expression -> expression PLUS term": add命令を追加してexpressionの値とtermの値の加算を行う|
    \item \verb|"expression -> expression MINUS term": sub命令を追加してexpressionの値からtermの値を引いた値を計算する|
    \item \verb|"term -> term DIV factor": DIV命令を追加してtermの値をfactorの値で割った値を計算する|
    \item \verb|"id_list -> IDENT": IDENTを記号表に追加する|
    \item \verb|"id_list -> id_list COMMA IDENT": IDENTを記号表に追加する|
\end{itemize}
\end{oframed}

\subsection{プログラムの内容}
\subsubsection{式の計算と代入文に対するコード生成のための処理}
上記の実装は構文解析のアクション部分に記述した。
記号表に対する操作は課題3で実装したinsert,lookup,deleteメソッドを呼び出すことによって行った.
また,スコープの変更はcompiler.pyでグローバル変数として宣言されているvarscopeを変更することによって行った.
命令の生成はaddCode()関数の引数として命令ごとに対応するクラスを呼び出して手続きを追加した.
完成したcompiler.pyを以下に示す.
\lstinputlisting[caption=kadai4/compiler.py,label=code:kadai4/compiler.py,language=Python]{../src/kadai4/compiler.py}

\section{動作確認の結果}
以下にk4-1.pに対するコンパイルの実行例を示す.

まず,k4-1.pを示す.
k4-1.pでは入力された数字をxに格納し,-x + (8 * x) div 4 - 1を出力するプログラムであり,この計算式はまとめるとx-1となる.
\lstinputlisting[caption=test-source/k4-1.p,label=code:test-source/k4-1.p,language=Pascal]{../src/test-source/k4-1.p}
以下のコマンドを実行してコンパイルを行った.
\begin{oframed}
\begin{verbatim}
python3 compiler.py k4-1.p
\end{verbatim}
\end{oframed}
上記の出力結果を以下に示す.
\begin{lstlisting}[caption=python3 compiler.py k4-1.pの出力]
insert:
[(x,Scope.GLOBAL_VAR)]
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
\end{lstlisting}
コンパイルで生成されたファイルは以下である.
\begin{lstlisting}[caption=k4-1.pのコンパイルで生成されたresult.ll,language=LLVM]
@x = common global i32 0, align 4

define i32 @main() {
    %1 = call i32 (i8*, ...) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.r, i64 0, i64 0), i32* @x)
    %2 = load i32, i32* @x, align 4
    %3 = sub nsw i32 0, %2
    %4 = load i32, i32* @x, align 4
    %5 = mul nsw i32 8, %4
    %6 = sdiv i32 %5, 4
    %7 = add nsw i32 %3, %6
    %8 = sub nsw i32 %7, 1
    store i32 %8, i32* @x, align 4
    %9 = load i32, i32* @x, align 4
    %10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.w, i64 0, i64 0), i32 %9)
    ret i32 0
}

declare i32 @printf(i8*, ...)
@.str.w = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
declare i32 @scanf(i8*, ...)
@.str.r = private unnamed_addr constant [3 x i8] c"%d\00", align 1
\end{lstlisting}

以下のコマンドを実行してコンパイルされたプログラムを実行した.
\begin{oframed}
\begin{verbatim}
lli result.ll
\end{verbatim}
\end{oframed}
実行すると入力待機状態となり,数字を入力すると入力した数より1小さい数が出力された.
\begin{lstlisting}[caption=k4-1.pをコンパイルしたプログラムを実行]
lli result.ll
5
4
\end{lstlisting}
想定された挙動を示したため,正しくコンパイラを実装することが出来たと考えられる.

\end{document}
