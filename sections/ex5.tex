%! TEX root = ../main.tex
\documentclass[main]{subfiles}

\begin{document}
\chapter{課題5}
\section{目的・概要}
課題5では,条件判定,if文,while文,for文にも対応したコンパイラになるように追加実装を行い,実際にコンパイルを行うことができるか確認した.

\section{使用機器・ソフトウェア}
\begin{itemize}
    \item Cent OS version 6.4(64ビット版)
    \item Python 3.9.16
    \item PLYパッケージ
\end{itemize}

\section{作業内容・プログラムの内容}
\subsection{作業内容}
この課題では,課題4で作成したファイルに追加実装を行った.
ここで追加実装を行ったファイルはcompiler.py,fundef.py,llvmcode.py,operand.pyであった.

\subsubsection{条件判定}
\begin{oframed}
\begin{itemize}
    \item 条件判定を行うためにはicmp命令が必要であるため,llvmcode.pyにicmp命令を生成するLLVMCodeIcmpクラスを定義.
    \item 条件分岐を行うためにはラベル番号を管理する必要があるため,ラベル番号カウンタをcompiler.pyのグローバル変数として追加.
    \item ラベルを扱うオブジェクトを定義するため,operand.pyのOtypeに\verb|NUMBERED_LABEL|を追加.
    \item compiler.pyに新たなラベル番号を持つOperandオブジェクトを返すgetLabel()関数を追加.
    \item ラベルのコード生成を行うためにllvmcode.pyにLLVMCodeLabelクラスを定義.
    \item br命令のコード生成を行うためにllvmcode.pyにLLVMCodeBrクラスを定義.
    \item conditionから記号列が生成される規則でicmp命令を生成する実装.
\end{itemize}
\end{oframed}

\subsubsection{if文}
\begin{oframed}
\begin{itemize}
    \item if文の生成において適切なタイミングでラベルを生成できるように\verb|if_statement -> IF condition THEN statement else_statement|の規則を\verb|if_statement -> IF condition if_act1 THEN statement if_act2 else_statement|に変更.
    \item \verb|if_act1 -> /* empty */|の規則で2つのラベル番号の取得とそれぞれのラベルへのbr命令を生成.
    \item \verb|if_act2 -> /* empty */|の規則で処理フローの合流地点のラベルの生成とそのラベルへのbr命令,条件分岐の一方のラベルのコード生成.
    \item \verb|else_statement -> ELSE statement|,\verb|else_statement -> /* empty */|の規則で,処理フローの合流地点のラベルのコード生成.
\end{itemize}
\end{oframed}

\subsubsection{while文}
\begin{oframed}
\begin{itemize}
    \item while文の生成において適切なタイミングでラベルを生成できるように\verb|while_statement -> WHILE condition DO statement|の規則を\verb|while_statement -> WHILE while_act1 condition while_act2 DO statement|に変更.
    \item \verb|while_statement -> WHILE while_act1 condition while_act2 DO statement|の規則で,ループの終了部分のラベルのコード生成とそこへのbr命令を生成.
    \item \verb|while_act1 -> /* empty */|の規則でループの条件判定を行う部分へのラベルのコード生成とそこへのbr命令を生成.
    \item \verb|while_act2 -> /* empty */|の規則でループ内で手続きを実行する部分のラベルのコード生成と,その手続きを行う部分のラベルかループを抜ける部分のラベルへの分岐を行うbr命令を生成.
\end{itemize}
\end{oframed}

\subsubsection{for文}
\begin{oframed}
\begin{itemize}
    \item for文の生成において適切なタイミングでラベルを生成できるように\verb|for_statement -> FOR IDENT ASSIGN expression for_act TO expression DO statement|の規則を\verb|for_statement -> FOR IDENT ASSIGN expression for_act1 TO expression for_act2 DO statement|に変更.
    \item \verb|for_statement -> FOR IDENT ASSIGN expression for_act1 TO expression for_act2 DO statement|の規則でループ終了時点での処理.つまり指定した変数の値を1つ大きくし,ループの条件判定を行う部分へのbr命令とループ終了部分のラベルのコード生成を行うように実装.
    \item \verb|for_act1 -> /* empty */|の規則でループ開始時の変数の初期化とループの条件判定を行う部分へのbr命令とそのラベルのコード生成を行うように実装.
    \item \verb|for_act2 -> /* empty */|の規則でループの条件判定部分とループの手続き部分かループ終了部分かへのbr命令を実装.
\end{itemize}
\end{oframed}

\subsection{プログラムの内容}
上記の実装を行った各ファイルを以下に示す.
\lstinputlisting[caption=kadai5/compiler.py,label=code:kadai5/compiler.py,language=Python]{../src/kadai5/compiler.py}
\lstinputlisting[caption=kadai5/fundef.py,label=code:kadai5/fundef.py,language=Python]{../src/kadai5/fundef.py}
\lstinputlisting[caption=kadai5/llvmcode.py,label=code:kadai5/llvmcode.py,language=Python]{../src/kadai5/llvmcode.py}
\lstinputlisting[caption=kadai5/operand.py,label=code:kadai5/operand.py,language=Python]{../src/kadai5/operand.py}
\lstinputlisting[caption=kadai5/symtab.py,label=code:kadai5/symtab.py,language=Python]{../src/kadai5/symtab.py}

\section{動作確認の結果}
以下にk5-if1.p,k5-if2.p,k5-while.p,k5-for.pをコンパイルした際の出力とコンパイルしたプログラムの実行を示す.
\subsection{k5-if1.p}
まず,k5-if1.pを示す.
k5-if1.pには入力された数字の絶対値を出力するプログラムが書かれている.
\lstinputlisting[caption=test-source/k5-if1.p,label=code:test-source/k5-if1.p,language=Pascal]{../src/test-source/k5-if1.p}
以下のコマンドを実行してコンパイルを行った.
\begin{oframed}
\begin{verbatim}
python3 compiler.py k5-if1.p
\end{verbatim}
\end{oframed}
上記の出力結果を以下に示す.
\begin{lstlisting}[caption=python3 compiler.py k5-if1.pの出力]
insert:
[(x,Scope.GLOBAL_VAR)]
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
\end{lstlisting}
コンパイルで生成されたファイルは以下である.
\begin{lstlisting}[caption=k5-if1.pのコンパイルで生成されたresult.ll,language=LLVM]
@x = common global i32 0, align 4

define i32 @main() {
    %1 = call i32 (i8*, ...) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.r, i64 0, i64 0), i32* @x)
    %2 = load i32, i32* @x, align 4
    %3 = icmp slt i32 %2, 0
    br i1 %3, label %L1, label %L2
    L1:
    %4 = load i32, i32* @x, align 4
    %5 = sub nsw i32 0, %4
    store i32 %5, i32* @x, align 4
    br label %L3
    L2:
    br label %L3
    L3:
    %6 = load i32, i32* @x, align 4
    %7 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.w, i64 0, i64 0), i32 %6)
    ret i32 0
}

declare i32 @printf(i8*, ...)
@.str.w = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
declare i32 @scanf(i8*, ...)
@.str.r = private unnamed_addr constant [3 x i8] c"%d\00", align 1
\end{lstlisting}
以下のコマンドを実行してコンパイルされたプログラムを実行した.
\begin{oframed}
\begin{verbatim}
lli result.ll
\end{verbatim}
\end{oframed}
実行すると入力待機状態となり,数字を入力すると入力した数の絶対値が出力された.
\begin{lstlisting}[caption=k5-if1.pをコンパイルしたプログラムを実行]
lli result.ll
5
5

lli result.ll
-5
5
\end{lstlisting}
想定された挙動を示したため,正しくコンパイラを実装することが出来たと考えられる.

\subsection{k5-if2.p}
まず,k5-if2.pを示す.
k5-if2.pには入力された2つの数の差の絶対値が出力されるプログラムが書かれている.
\lstinputlisting[caption=test-source/k5-if2.p,label=code:test-source/k5-if2.p,language=Pascal]{../src/test-source/k5-if2.p}
以下のコマンドを実行してコンパイルを行った.
\begin{oframed}
\begin{verbatim}
python3 compiler.py k5-if2.p
\end{verbatim}
\end{oframed}
上記の出力結果を以下に示す.
\begin{lstlisting}[caption=python3 compiler.py k5-if2.pの出力]
insert:
[(x,Scope.GLOBAL_VAR)]
insert:
[(x,Scope.GLOBAL_VAR), (y,Scope.GLOBAL_VAR)]
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:y,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:y,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:y,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:y,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:y,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
lookup:
name:x,scope:Scope.GLOBAL_VAR
\end{lstlisting}
コンパイルで生成されたファイルは以下である.
\begin{lstlisting}[caption=k5-if2.pのコンパイルで生成されたresult.ll,language=LLVM]
@x = common global i32 0, align 4
@y = common global i32 0, align 4

define i32 @main() {
    %1 = call i32 (i8*, ...) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.r, i64 0, i64 0), i32* @x)
    %2 = call i32 (i8*, ...) @scanf(i8* getelementptr inbounds ([3 x i8], [3 x i8]* @.str.r, i64 0, i64 0), i32* @y)
    %3 = load i32, i32* @x, align 4
    %4 = load i32, i32* @y, align 4
    %5 = icmp ne i32 %3, %4
    br i1 %5, label %L1, label %L2
    L1:
    %6 = load i32, i32* @x, align 4
    %7 = load i32, i32* @y, align 4
    %8 = icmp sge i32 %6, %7
    br i1 %8, label %L3, label %L4
    L3:
    %9 = load i32, i32* @x, align 4
    %10 = load i32, i32* @y, align 4
    %11 = sub nsw i32 %9, %10
    store i32 %11, i32* @x, align 4
    br label %L5
    L4:
    %12 = load i32, i32* @y, align 4
    %13 = load i32, i32* @x, align 4
    %14 = sub nsw i32 %12, %13
    store i32 %14, i32* @x, align 4
    br label %L5
    L5:
    %15 = load i32, i32* @x, align 4
    %16 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.w, i64 0, i64 0), i32 %15)
    br label %L6
    L2:
    %17 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.w, i64 0, i64 0), i32 0)
    br label %L6
    L6:
    ret i32 0
}

declare i32 @printf(i8*, ...)
@.str.w = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
declare i32 @scanf(i8*, ...)
@.str.r = private unnamed_addr constant [3 x i8] c"%d\00", align 1
\end{lstlisting}
以下のコマンドを実行してコンパイルされたプログラムを実行した.
\begin{oframed}
\begin{verbatim}
lli result.ll
\end{verbatim}
\end{oframed}
実行すると入力待機状態となり,2つの数字を入力するとその2つの数の差の絶対値が出力された.
\begin{lstlisting}[caption=k5-if1.pをコンパイルしたプログラムを実行]
lli result.ll
10
6 
4

lli result.ll
8
17
9

lli result.ll
5
5
0
\end{lstlisting}
想定された挙動を示したため,正しくコンパイラを実装することが出来たと考えられる.


\subsection{k5-while.p}
まず,k5-while.pを示す.
k5-while.pには10から1までの整数の和を出力するプログラムが書かれている.つまり55が出力される.
\lstinputlisting[caption=test-source/k5-while.p,label=code:test-source/k5-while.p,language=Pascal]{../src/test-source/k5-while.p}
以下のコマンドを実行してコンパイルを行った.
\begin{oframed}
\begin{verbatim}
python3 compiler.py k5-while.p
\end{verbatim}
\end{oframed}
上記の出力結果を以下に示す.
\begin{lstlisting}[caption=python3 compiler.py k5-while.pの出力]
python3 compiler.py k5-while.p
insert:
[(n,Scope.GLOBAL_VAR)]
insert:
[(n,Scope.GLOBAL_VAR), (sum,Scope.GLOBAL_VAR)]
lookup:
name:n,scope:Scope.GLOBAL_VAR
lookup:
name:sum,scope:Scope.GLOBAL_VAR
lookup:
name:n,scope:Scope.GLOBAL_VAR
lookup:
name:sum,scope:Scope.GLOBAL_VAR
lookup:
name:n,scope:Scope.GLOBAL_VAR
lookup:
name:sum,scope:Scope.GLOBAL_VAR
lookup:
name:n,scope:Scope.GLOBAL_VAR
lookup:
name:n,scope:Scope.GLOBAL_VAR
lookup:
name:sum,scope:Scope.GLOBAL_VAR
\end{lstlisting}
コンパイルで生成されたファイルは以下である.
\begin{lstlisting}[caption=k5-while.pのコンパイルで生成されたresult.ll,language=LLVM]
@n = common global i32 0, align 4
@sum = common global i32 0, align 4

define i32 @main() {
    store i32 10, i32* @n, align 4
    store i32 0, i32* @sum, align 4
    br label %L1
    L1:
    %1 = load i32, i32* @n, align 4
    %2 = icmp sgt i32 %1, 0
    br i1 %2, label %L2, label %L3
    L2:
    %3 = load i32, i32* @sum, align 4
    %4 = load i32, i32* @n, align 4
    %5 = add nsw i32 %3, %4
    store i32 %5, i32* @sum, align 4
    %6 = load i32, i32* @n, align 4
    %7 = sub nsw i32 %6, 1
    store i32 %7, i32* @n, align 4
    br label %L1
    L3:
    %8 = load i32, i32* @sum, align 4
    %9 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.w, i64 0, i64 0), i32 %8)
    ret i32 0
}

declare i32 @printf(i8*, ...)
@.str.w = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
\end{lstlisting}
以下のコマンドを実行してコンパイルされたプログラムを実行した.
\begin{oframed}
\begin{verbatim}
lli result.ll
\end{verbatim}
\end{oframed}
実行すると想定通り55が出力された.
\begin{lstlisting}[caption=k5-if1.pをコンパイルしたプログラムを実行]
lli result.ll
55
\end{lstlisting}
想定された挙動を示したため,正しくコンパイラを実装することが出来たと考えられる.

\subsection{k5-for.p}
まず,k5-for.pを示す.
k5-for.pにはfor文を用いて1から10までの和を計算し,出力するプログラムが書かれている.
\lstinputlisting[caption=test-source/k5-for.p,label=code:test-source/k5-for.p,language=Pascal]{../src/test-source/k5-for.p}
以下のコマンドを実行してコンパイルを行った.
\begin{oframed}
\begin{verbatim}
python3 compiler.py k5-for.p
\end{verbatim}
\end{oframed}
上記の出力結果を以下に示す.
\begin{lstlisting}[caption=python3 compiler.py k5-for.pの出力]
python3 compiler.py k5-for.p
insert:
[(n,Scope.GLOBAL_VAR)]
insert:
[(n,Scope.GLOBAL_VAR), (sum,Scope.GLOBAL_VAR)]
insert:
[(n,Scope.GLOBAL_VAR), (sum,Scope.GLOBAL_VAR), (i,Scope.GLOBAL_VAR)]
lookup:
name:n,scope:Scope.GLOBAL_VAR
lookup:
name:sum,scope:Scope.GLOBAL_VAR
lookup:
name:i,scope:Scope.GLOBAL_VAR
lookup:
name:n,scope:Scope.GLOBAL_VAR
lookup:
name:i,scope:Scope.GLOBAL_VAR
lookup:
name:sum,scope:Scope.GLOBAL_VAR
lookup:
name:i,scope:Scope.GLOBAL_VAR
lookup:
name:sum,scope:Scope.GLOBAL_VAR
lookup:
name:i,scope:Scope.GLOBAL_VAR
lookup:
name:sum,scope:Scope.GLOBAL_VAR
\end{lstlisting}
コンパイルで生成されたファイルは以下である.
\begin{lstlisting}[caption=k5-for.pのコンパイルで生成されたresult.ll,language=LLVM]
@n = common global i32 0, align 4
@sum = common global i32 0, align 4
@i = common global i32 0, align 4

define i32 @main() {
    store i32 10, i32* @n, align 4
    store i32 0, i32* @sum, align 4
    store i32 1, i32* @i, align 4
    br label %L1
    L1:
    %1 = load i32, i32* @n, align 4
    %2 = load i32, i32* @i, align 4
    %3 = icmp sle i32 %2, %1
    br i1 %3, label %L2, label %L3
    L2:
    %4 = load i32, i32* @sum, align 4
    %5 = load i32, i32* @i, align 4
    %6 = add nsw i32 %4, %5
    store i32 %6, i32* @sum, align 4
    %7 = load i32, i32* @i, align 4
    %8 = add nsw i32 %7, 1
    store i32 %8, i32* @i, align 4
    br label %L1
    L3:
    %9 = load i32, i32* @sum, align 4
    %10 = call i32 (i8*, ...) @printf(i8* getelementptr inbounds ([4 x i8], [4 x i8]* @.str.w, i64 0, i64 0), i32 %9)
    ret i32 0
}

declare i32 @printf(i8*, ...)
@.str.w = private unnamed_addr constant [4 x i8] c"%d\0A\00", align 1
\end{lstlisting}
以下のコマンドを実行してコンパイルされたプログラムを実行した.
\begin{oframed}
\begin{verbatim}
lli result.ll
\end{verbatim}
\end{oframed}
実行すると想定通り55が出力された.
\begin{lstlisting}[caption=k5-for.pをコンパイルしたプログラムを実行]
lli result.ll
55
\end{lstlisting}
想定された挙動を示したため,正しくコンパイラを実装することが出来たと考えられる.

\end{document}
